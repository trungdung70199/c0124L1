{
  "version": 3,
  "sources": ["../../@radix-ui/react-use-previous/dist/packages/react/use-previous/src/index.ts", "../../@radix-ui/react-use-previous/dist/packages/react/use-previous/src/usePrevious.tsx", "../../@radix-ui/react-use-size/dist/packages/react/use-size/src/index.ts", "../../@radix-ui/react-use-size/dist/packages/react/use-size/src/useSize.tsx", "../../@radix-ui/react-switch/dist/packages/react/switch/src/index.ts", "../../@radix-ui/react-switch/dist/packages/react/switch/src/Switch.tsx"],
  "sourcesContent": ["export { usePrevious } from './usePrevious';\n", "import * as React from 'react';\n\nfunction usePrevious<T>(value: T) {\n  const ref = React.useRef({ value, previous: value });\n\n  // We compare values before making an update to ensure that\n  // a change has been made. This ensures the previous value is\n  // persisted correctly between renders.\n  return React.useMemo(() => {\n    if (ref.current.value !== value) {\n      ref.current.previous = ref.current.value;\n      ref.current.value = value;\n    }\n    return ref.current.previous;\n  }, [value]);\n}\n\nexport { usePrevious };\n", "export { useSize } from './useSize';\n", "/// <reference types=\"resize-observer-browser\" />\n\nimport * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\nfunction useSize(element: HTMLElement | null) {\n  const [size, setSize] = React.useState<{ width: number; height: number } | undefined>(undefined);\n\n  useLayoutEffect(() => {\n    if (element) {\n      // provide size as early as possible\n      setSize({ width: element.offsetWidth, height: element.offsetHeight });\n\n      const resizeObserver = new ResizeObserver((entries) => {\n        if (!Array.isArray(entries)) {\n          return;\n        }\n\n        // Since we only observe the one element, we don't need to loop over the\n        // array\n        if (!entries.length) {\n          return;\n        }\n\n        const entry = entries[0];\n        let width: number;\n        let height: number;\n\n        if ('borderBoxSize' in entry) {\n          const borderSizeEntry = entry['borderBoxSize'];\n          // iron out differences between browsers\n          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;\n          width = borderSize['inlineSize'];\n          height = borderSize['blockSize'];\n        } else {\n          // for browsers that don't support `borderBoxSize`\n          // we calculate it ourselves to get the correct border box.\n          width = element.offsetWidth;\n          height = element.offsetHeight;\n        }\n\n        setSize({ width, height });\n      });\n\n      resizeObserver.observe(element, { box: 'border-box' });\n\n      return () => resizeObserver.unobserve(element);\n    } else {\n      // We only want to reset to `undefined` when the element becomes `null`,\n      // not if it changes to another element.\n      setSize(undefined);\n    }\n  }, [element]);\n\n  return size;\n}\n\nexport { useSize };\n", "export {\n  createSwitchScope,\n  //\n  Switch,\n  SwitchThumb,\n  //\n  Root,\n  Thumb,\n} from './Switch';\nexport type { SwitchProps, SwitchThumbProps } from './Switch';\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useSize } from '@radix-ui/react-use-size';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Switch\n * -----------------------------------------------------------------------------------------------*/\n\nconst SWITCH_NAME = 'Switch';\n\ntype ScopedProps<P> = P & { __scopeSwitch?: Scope };\nconst [createSwitchContext, createSwitchScope] = createContextScope(SWITCH_NAME);\n\ntype SwitchContextValue = { checked: boolean; disabled?: boolean };\nconst [SwitchProvider, useSwitchContext] = createSwitchContext<SwitchContextValue>(SWITCH_NAME);\n\ntype SwitchElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = Radix.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface SwitchProps extends PrimitiveButtonProps {\n  checked?: boolean;\n  defaultChecked?: boolean;\n  required?: boolean;\n  onCheckedChange?(checked: boolean): void;\n}\n\nconst Switch = React.forwardRef<SwitchElement, SwitchProps>(\n  (props: ScopedProps<SwitchProps>, forwardedRef) => {\n    const {\n      __scopeSwitch,\n      name,\n      checked: checkedProp,\n      defaultChecked,\n      required,\n      disabled,\n      value = 'on',\n      onCheckedChange,\n      ...switchProps\n    } = props;\n    const [button, setButton] = React.useState<HTMLButtonElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));\n    const hasConsumerStoppedPropagationRef = React.useRef(false);\n    // We set this to true by default so that events bubble to forms without JS (SSR)\n    const isFormControl = button ? Boolean(button.closest('form')) : true;\n    const [checked = false, setChecked] = useControllableState({\n      prop: checkedProp,\n      defaultProp: defaultChecked,\n      onChange: onCheckedChange,\n    });\n\n    return (\n      <SwitchProvider scope={__scopeSwitch} checked={checked} disabled={disabled}>\n        <Primitive.button\n          type=\"button\"\n          role=\"switch\"\n          aria-checked={checked}\n          aria-required={required}\n          data-state={getState(checked)}\n          data-disabled={disabled ? '' : undefined}\n          disabled={disabled}\n          value={value}\n          {...switchProps}\n          ref={composedRefs}\n          onClick={composeEventHandlers(props.onClick, (event) => {\n            setChecked((prevChecked) => !prevChecked);\n            if (isFormControl) {\n              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();\n              // if switch is in a form, stop propagation from the button so that we only propagate\n              // one click event (from the input). We propagate changes from an input so that native\n              // form validation works and form events reflect switch updates.\n              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();\n            }\n          })}\n        />\n        {isFormControl && (\n          <BubbleInput\n            control={button}\n            bubbles={!hasConsumerStoppedPropagationRef.current}\n            name={name}\n            value={value}\n            checked={checked}\n            required={required}\n            disabled={disabled}\n            // We transform because the input is absolutely positioned but we have\n            // rendered it **after** the button. This pulls it back to sit on top\n            // of the button.\n            style={{ transform: 'translateX(-100%)' }}\n          />\n        )}\n      </SwitchProvider>\n    );\n  }\n);\n\nSwitch.displayName = SWITCH_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SwitchThumb\n * -----------------------------------------------------------------------------------------------*/\n\nconst THUMB_NAME = 'SwitchThumb';\n\ntype SwitchThumbElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface SwitchThumbProps extends PrimitiveSpanProps {}\n\nconst SwitchThumb = React.forwardRef<SwitchThumbElement, SwitchThumbProps>(\n  (props: ScopedProps<SwitchThumbProps>, forwardedRef) => {\n    const { __scopeSwitch, ...thumbProps } = props;\n    const context = useSwitchContext(THUMB_NAME, __scopeSwitch);\n    return (\n      <Primitive.span\n        data-state={getState(context.checked)}\n        data-disabled={context.disabled ? '' : undefined}\n        {...thumbProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nSwitchThumb.displayName = THUMB_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype InputProps = Radix.ComponentPropsWithoutRef<'input'>;\ninterface BubbleInputProps extends Omit<InputProps, 'checked'> {\n  checked: boolean;\n  control: HTMLElement | null;\n  bubbles: boolean;\n}\n\nconst BubbleInput = (props: BubbleInputProps) => {\n  const { control, checked, bubbles = true, ...inputProps } = props;\n  const ref = React.useRef<HTMLInputElement>(null);\n  const prevChecked = usePrevious(checked);\n  const controlSize = useSize(control);\n\n  // Bubble checked change to parents (e.g form change event)\n  React.useEffect(() => {\n    const input = ref.current!;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'checked') as PropertyDescriptor;\n    const setChecked = descriptor.set;\n    if (prevChecked !== checked && setChecked) {\n      const event = new Event('click', { bubbles });\n      setChecked.call(input, checked);\n      input.dispatchEvent(event);\n    }\n  }, [prevChecked, checked, bubbles]);\n\n  return (\n    <input\n      type=\"checkbox\"\n      aria-hidden\n      defaultChecked={checked}\n      {...inputProps}\n      tabIndex={-1}\n      ref={ref}\n      style={{\n        ...props.style,\n        ...controlSize,\n        position: 'absolute',\n        pointerEvents: 'none',\n        opacity: 0,\n        margin: 0,\n      }}\n    />\n  );\n};\n\nfunction getState(checked: boolean) {\n  return checked ? 'checked' : 'unchecked';\n}\n\nconst Root = Switch;\nconst Thumb = SwitchThumb;\n\nexport {\n  createSwitchScope,\n  //\n  Switch,\n  SwitchThumb,\n  //\n  Root,\n  Thumb,\n};\nexport type { SwitchProps, SwitchThumbProps };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;ACEA,SAASA,0CAAeC,OAAU;AAChC,QAAMC,UAAMC,aAAAA,QAAa;IAH3B;IAGoCC,UAAUH;GAAhC;AAKZ,aAAOE,aAAAA,SAAc,MAAM;AACzB,QAAID,IAAIG,QAAQJ,UAAUA,OAAO;AAC/BC,UAAIG,QAAQD,WAAWF,IAAIG,QAAQJ;AACnCC,UAAIG,QAAQJ,QAAQA;;AAEtB,WAAOC,IAAIG,QAAQD;KAClB;IAACH;GANG;;;;;AEHT,SAASK,0CAAQC,SAA6B;AAC5C,QAAM,CAACC,MAAMC,OAAP,QAAkBC,cAAAA,UAA8DC,MAA9D;AAExBC,4CAAgB,MAAM;AACpB,QAAIL,SAAS;AAEXE,cAAQ;QAAEI,OAAON,QAAQO;QAAaC,QAAQR,QAAQS;OAA/C;AAEP,YAAMC,iBAAiB,IAAIC,eAAgBC,CAAAA,YAAY;AACrD,YAAI,CAACC,MAAMC,QAAQF,OAAd;AACH;AAKF,YAAI,CAACA,QAAQG;AACX;AAGF,cAAMC,QAAQJ,QAAQ,CAAD;AACrB,YAAIN;AACJ,YAAIE;AAEJ,YAAI,mBAAmBQ,OAAO;AAC5B,gBAAMC,kBAAkBD,MAAM,eAAD;AAE7B,gBAAME,aAAaL,MAAMC,QAAQG,eAAd,IAAiCA,gBAAgB,CAAD,IAAMA;AACzEX,kBAAQY,WAAW,YAAD;AAClBV,mBAASU,WAAW,WAAD;eACd;AAGLZ,kBAAQN,QAAQO;AAChBC,mBAASR,QAAQS;;AAGnBP,gBAAQ;UAzChB;UAAA;SAyCe;OA5Bc;AA+BvBQ,qBAAeS,QAAQnB,SAAS;QAAEoB,KAAK;OAAvC;AAEA,aAAO,MAAMV,eAAeW,UAAUrB,OAAzB;;AAIbE,cAAQE,MAAD;KAER;IAACJ;GA5CW;AA8Cf,SAAOC;;;;AEtCT,IAAMqB,oCAAc;AAGpB,IAAM,CAACC,2CAAqBC,yCAAtB,IAA2CC,yCAAmBH,iCAAD;AAGnE,IAAM,CAACI,sCAAgBC,sCAAjB,IAAqCJ,0CAAwCD,iCAArB;AAW9D,IAAMM,gDAASC,cAAAA,YACb,CAACC,OAAiCC,iBAAiB;AACjD,QAAM,EAAA,eAAA,MAGJC,SAASC,aAHL,gBAAA,UAAA,UAAA,QAOI,MAPJ,iBASJ,GAAGC,YAAH,IACEJ;AACJ,QAAM,CAACK,QAAQC,SAAT,QAAsBP,cAAAA,UAAyC,IAAzC;AAC5B,QAAMQ,eAAeC;IAAgBP;IAAeQ,CAAAA,SAASH,UAAUG,IAAD;EAAlC;AACpC,QAAMC,uCAAmCX,cAAAA,QAAa,KAAb;AAEzC,QAAMY,gBAAgBN,SAASO,QAAQP,OAAOQ,QAAQ,MAAf,CAAD,IAA2B;AACjE,QAAM,CAACX,UAAU,OAAOY,UAAlB,IAAgCC,yCAAqB;IACzDC,MAAMb;IACNc,aAAaC;IACbC,UAAUC;GAH8C;AAM1D,aACE,cAAAC,eAAC,sCADH;IACkB,OAAOC;IAAe;IAAkB;SACtD,cAAAD,eAAC,0CAAU,QADb,SAAA;IAEI,MAAK;IACL,MAAK;IACL,gBAAcnB;IACd,iBAAeqB;IACf,cAAYC,+BAAStB,OAAD;IACpB,iBAAeuB,WAAW,KAAKC;IAC/B;IACA;KACItB,aATN;IAUE,KAAKG;IACL,SAASoB,0CAAqB3B,MAAM4B,SAAUC,CAAAA,UAAU;AACtDf;QAAYgB,CAAAA,gBAAgB,CAACA;MAAnB;AACV,UAAInB,eAAe;AACjBD,yCAAiCqB,UAAUF,MAAMG,qBAAN;AAI3C,YAAI,CAACtB,iCAAiCqB;AAASF,gBAAMI,gBAAN;;KAPtB;GAX/B,CAAA,GAsBCtB,qBACC,cAAAU,eAAC,mCAvBH;IAwBI,SAAShB;IACT,SAAS,CAACK,iCAAiCqB;IAC3C;IACA;IACA;IACA;IACA;IAIA,OAAO;MAAEG,WAAW;;GAXtB,CAxBJ;CAzBS;AAoEf,OAAA,OAAA,2CAAA;EAAA,aAAA;CAAA;AAMA,IAAMC,mCAAa;AAMnB,IAAMC,gDAAcrC,cAAAA,YAClB,CAACC,OAAsCC,iBAAiB;AACtD,QAAM,EAAA,eAAiB,GAAGoC,WAAH,IAAkBrC;AACzC,QAAMsC,UAAUzC,uCAAiBsC,kCAAYb,aAAb;AAChC,aACE,cAAAD,eAAC,0CAAU,MADb,SAAA;IAEI,cAAYG,+BAASc,QAAQpC,OAAT;IACpB,iBAAeoC,QAAQb,WAAW,KAAKC;KACnCW,YAHN;IAIE,KAAKpC;GAJP,CAAA;CALc;AAepB,OAAA,OAAA,2CAAA;EAAA,aAAA;CAAA;AAWA,IAAMsC,oCAAevC,CAAAA,UAA4B;AAC/C,QAAM,EAAA,SAAA,SAAA,UAA8B,MAAM,GAAGwC,WAAH,IAAkBxC;AAC5D,QAAMyC,UAAM1C,cAAAA,QAA+B,IAA/B;AACZ,QAAM+B,cAAcY,0CAAYxC,OAAD;AAC/B,QAAMyC,cAAcC,0CAAQC,OAAD;AAG3B9C,oBAAAA,WAAgB,MAAM;AACpB,UAAM+C,QAAQL,IAAIV;AAClB,UAAMgB,aAAaC,OAAOC,iBAAiBC;AAC3C,UAAMC,aAAaC,OAAOC,yBAAyBN,YAAY,SAA5C;AACnB,UAAMjC,aAAaqC,WAAWG;AAC9B,QAAIxB,gBAAgB5B,WAAWY,YAAY;AACzC,YAAMe,QAAQ,IAAI0B,MAAM,SAAS;;OAAnB;AACdzC,iBAAW0C,KAAKV,OAAO5C,OAAvB;AACA4C,YAAMW,cAAc5B,KAApB;;KAED;IAACC;IAAa5B;IAASwD;GAV1B;AAYA,aACE,cAAArC,eADF,SAAA,SAAA;IAEI,MAAK;IACL,eAAA;IACA,gBAAgBnB;KACZsC,YAJN;IAKE,UAAU;IACV;IACA,OAAO;MACL,GAAGxC,MAAM2D;MACT,GAAGhB;MACHiB,UAAU;MACVC,eAAe;MACfC,SAAS;MACTC,QAAQ;;GAbZ,CAAA;;AAmBJ,SAASvC,+BAAStB,SAAkB;AAClC,SAAOA,UAAU,YAAY;;AAG/B,IAAM8D,4CAAOlE;AACb,IAAMmE,4CAAQ7B;",
  "names": ["usePrevious", "value", "ref", "React", "previous", "current", "useSize", "element", "size", "setSize", "React", "undefined", "useLayoutEffect", "width", "offsetWidth", "height", "offsetHeight", "resizeObserver", "ResizeObserver", "entries", "Array", "isArray", "length", "entry", "borderSizeEntry", "borderSize", "observe", "box", "unobserve", "SWITCH_NAME", "createSwitchContext", "createSwitchScope", "createContextScope", "SwitchProvider", "useSwitchContext", "Switch", "React", "props", "forwardedRef", "checked", "checkedProp", "switchProps", "button", "setButton", "composedRefs", "useComposedRefs", "node", "hasConsumerStoppedPropagationRef", "isFormControl", "Boolean", "closest", "setChecked", "useControllableState", "prop", "defaultProp", "defaultChecked", "onChange", "onCheckedChange", "$irPIl$createElement", "__scopeSwitch", "required", "getState", "disabled", "undefined", "composeEventHandlers", "onClick", "event", "prevChecked", "current", "isPropagationStopped", "stopPropagation", "transform", "THUMB_NAME", "SwitchThumb", "thumbProps", "context", "BubbleInput", "inputProps", "ref", "usePrevious", "controlSize", "useSize", "control", "input", "inputProto", "window", "HTMLInputElement", "prototype", "descriptor", "Object", "getOwnPropertyDescriptor", "set", "Event", "call", "dispatchEvent", "bubbles", "style", "position", "pointerEvents", "opacity", "margin", "Root", "Thumb"]
}
